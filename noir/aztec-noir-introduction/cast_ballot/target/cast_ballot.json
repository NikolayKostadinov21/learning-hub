{"noir_version":"0.30.0+af57471035e4fa7eaffa71693219df6d029dbcde","hash":10888349518659559354,"abi":{"parameters":[{"name":"secret","type":{"kind":"field"},"visibility":"private"},{"name":"token_budget","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"votes","type":{"kind":"array","length":10,"type":{"kind":"integer","sign":"unsigned","width":32}},"visibility":"private"}],"param_witnesses":{"secret":[{"start":0,"end":1}],"token_budget":[{"start":1,"end":2}],"votes":[{"start":2,"end":12}]},"return_type":{"abi_type":{"kind":"field"},"visibility":"public"},"return_witnesses":[34],"error_types":{}},"bytecode":"H4sIAAAAAAAA/9WaWW/aQBDHzX3f972gqqqqqvKCCeatX6OPIEyDCjhKTKN+eVSvMk6XhbxsZ6xmJRgP8s6sf/P3sBwR42VM/McCjiP+IwaWSX5U8WOKH1f8hOInFT+l+GnFzyh+VvFz4AdrFuMbWPPfBo/C9apxZ+adZTmLqcNnfGVOl2t7blrz9Z3NbT6355upPZs5tmUvluvlwlxya+bw7Xw520LgPN4azYBDnpBDTNICJocCAYeCxCEYMWQeiPXjBUSeRQKeRUJdiV4RJ9BViYBDKQRdIdaPlxB5lgl4lgl1Jd5zEgS6qhBwqISgK8T68QoizyoBzyqhrsTeJUmgqxoBh1oIukKsH68h8qwT8KwT6krsgVMEumoQcGiEoCvE+vEGIs8mAc8moa7EZ6k0ga5aBBxaIegKsX68hcizTcCzTagr8Zk8Q6CrDgGHTgi6Qqwf7yDy7BLw7BLqSny3kyXQVY+AQy8EXSHWj/cQefYJePYJdSW+I8wR6GpAwGEQgq4Q68cHiDyHBDyHwDMBcaPG9Ygi8438X0x4cHDj0tFiy1xHYJnx957DSviaOCgwM65vmPg7KahmrCnE4iPEdTEioWE33RFyXcVGNiet92y8NIQz6OsMehI2ATYJNgU2DTYDNgs2B1aMsXE5sJvOGJHxxMBtxMH9mFOuP/jBMAFMU8AyAwzlN+2IdCzWV5di5aXjgPPK85zDg8c8lx1Oe2/3sP/NnnfePXN/OY/bvfssTirqTixLE/vXE1ebzfWcqm6yukaypm6ytkayrm6yvkayoW4yppFsopvsg0ayj7rJPmkk+6yb7ItGsq+6yUyNZJY0J/g7w3f3xFaPDoO5u+MPMf305LCD67/suT+d4xPz7ldH/8k/be/Hcjbj146TBpuUYqtbyVtby4lx+RcCuYNFpDkx41Jrt7peVIr31jmRN+KonVeMyo3X/gAjEKXCCyIAAA==","debug_symbols":"tZhLasMwFEX3orEHeh9JkbdSQlESpxiMHGKnUIz3XruN25KGZJDcmZ91OYOLHgc0mF21Ob291nnfdqZ8GUzTblNft3maBkP09a87pDyPXZ+OvSlJhQpT5d38GWgszL5uKlOqH4t/YSU5Z5X1b3RdGGIsXrB4xeLdw3iJ4QfvLvEeiw/YclZYfISWwxaLx24tY7eWBVuOYvEOW47H4gO2nBUWH6HliMXiCVqOMBaPda1gXStY1wrWtYJ1rWBdK1jXKta1inWtYl2rWNcq1rWKda1iXatY1yrWtfoE10Y+Zx3bC7yzWDxh8YzFX99aZ+2Cd8q38UTslzD5u+GwXARi+r0JHMf1NLynY502TTW/GMxnp7xdHhCmsf84fJ9M2U8=","file_map":{"29":{"source":"mod poseidon;\nmod mimc;\nmod poseidon2;\n\nuse crate::default::Default;\nuse crate::uint128::U128;\nuse crate::sha256::{digest, sha256_var};\n\n#[foreign(sha256)]\n// docs:start:sha256\npub fn sha256<N>(input: [u8; N]) -> [u8; 32]\n// docs:end:sha256\n{}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<N>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<N>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\nstruct PedersenPoint {\n   x : Field,\n   y : Field,\n}\n\npub fn pedersen_commitment<N>(input: [Field; N]) -> PedersenPoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[foreign(pedersen_commitment)]\npub fn __pedersen_commitment_with_separator<N>(input: [Field; N], separator: u32) -> [Field; 2] {}\n\npub fn pedersen_commitment_with_separator<N>(input: [Field; N], separator: u32) -> PedersenPoint {\n    let values = __pedersen_commitment_with_separator(input, separator);\n    PedersenPoint { x: values[0], y: values[1] }\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<N>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[foreign(pedersen_hash)]\npub fn pedersen_hash_with_separator<N>(input: [Field; N], separator: u32) -> Field {}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes(32).as_array();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n#[foreign(keccak256)]\n// docs:start:keccak256\npub fn keccak256<N>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<N>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n#[foreign(sha256_compression)]\npub fn sha256_compression(_input: [u32; 16], _state: [u32; 8]) -> [u32; 8] {}\n\n// Generic hashing support. \n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\ntrait Hash{\n    fn hash<H>(self, state: &mut H) where H: Hasher;\n}\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\ntrait Hasher{\n    fn finish(self) -> Field;\n    \n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\ntrait BuildHasher<H> where H: Hasher{\n    fn build_hasher(self) -> H;\n}\n\nstruct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default\n{\n    fn build_hasher(_self: Self) -> H{\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default\n{\n    fn default() -> Self{\n        BuildHasherDefault{}\n    }    \n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H) where H: Hasher {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, N> Hash for [T; N] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B) where A: Hash, B: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C) where A: Hash, B: Hash, C: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D) where A: Hash, B: Hash, C: Hash, D: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E) where A: Hash, B: Hash, C: Hash, D: Hash, E: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n","path":"std/hash.nr"},"46":{"source":"use dep::std;\nglobal CANDIDATE_COUNT = 10;\n\n// Constrains votes to obey quadratic votes cost function\nfn check_within_budget(votes: [u32; CANDIDATE_COUNT], token_budget: u32) {\n\t// Sum squared votes into this variable\n\tlet mut tokens_spent: u32 = 0;\n\t// Loop over the vote for each candidate\n\tfor i in 0..CANDIDATE_COUNT {\n\t\tlet vote = votes[i];\n\t\t// Accumulate each squared vote\n\t\ttokens_spent = tokens_spent + (vote * vote);\n\t};\n\n\t// Check we haven't used more tokens than allowed\n\tassert (tokens_spent <= token_budget, \"You are attempting to use more tokens than the allowed!\");\n}\n\nfn calculate_ballot_commitment(secret: Field, votes: [u32; CANDIDATE_COUNT]) -> Field {\n\t// Form the transcript by prepending the votes with the secret\n    // Note: In the future it will be possible to size this array\n    // more flexibly with the use of comptime expressions.\n\tlet mut transcript = [0; CANDIDATE_COUNT + 1];\n\ttranscript[0] = secret;\n\tfor i in 0..CANDIDATE_COUNT {\n\t\t// Pedersen expects a transcript of Field elements, hence the cast\n\t\ttranscript[i + 1] = votes[i] as Field;\n\t}\n\n\t// Returns the x coordinate of the EC point\n\tstd::hash::pedersen_hash(transcript)\n}\n\nfn main(\n\t// For shielding the commitment from brute-force attacks\n\tsecret: Field,\n\t// Budget to be enforced\n\ttoken_budget: pub u32,\n    // The votes for each candidate (identified by index)\n    votes: [u32; CANDIDATE_COUNT],\n) -> pub Field {\n\t// Enforce QV rules\n\tcheck_within_budget(votes, token_budget);\n\t// Reveal the commitment\n\tcalculate_ballot_commitment(secret, votes)\n}\n","path":"/root/learning/learning-hub/noir/aztec-noir-introduction/cast_ballot/src/main.nr"}},"names":["main"]}